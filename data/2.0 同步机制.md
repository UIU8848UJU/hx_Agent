
[TOC]


# <span style="color:#6C8EBF">🔒 锁（Lock）：并发编程的资源守护者</span>  


## <span style="color:#8AAE8D">一、锁的底层实现与基本操作</span>  
### <span style="color:#87CEEB">1. 底层接口（POSIX视角）  
```cpp  
constexpr mutex() noexcept;  
mutex( const mutex& ) = delete; // 禁止拷贝  
```  
- **核心特性**：  
  - 互斥锁底层对应`pthread_mutex_t`（Linux）或`SRWLOCK`（Windows）  
  - 构造时初始化系统互斥原语，析构时释放  


### <span style="color:#87CEEB">2. 基本操作（类比门锁）  
```cpp  
#include <mutex>  
mutex mtx;  // 初始化门锁  

mtx.lock();    // 上锁（转动钥匙）  
// 临界区（安全空间）  
mtx.unlock();  // 解锁（拔出钥匙）  

bool got_lock = mtx.try_lock();  // 尝试上锁（不阻塞，类似试钥匙）  
```  


## <span style="color:#8AAE8D">二、智能锁：RAII思想的锁管理</span>  
### <span style="color:#87CEEB">1. lock_guard：简单可靠的自动锁  
**特性**：  
- 构造时加锁，析构时解锁（自动关门的智能锁）  
- 不支持解锁后重新加锁（一次开锁关门循环）  

```cpp  
void safe_operation() {  
    mutex mtx;  
    {  
        lock_guard<mutex> lk(mtx);  // 进入作用域加锁  
        // 临界区...  
    }  // 离开作用域解锁（自动释放）  
}  
```  


### <span style="color:#87CEEB">2. unique_lock：灵活强大的智能锁  
**特性**：  
- 支持延迟加锁、尝试加锁、超时加锁（多功能智能锁）  
- 可手动控制锁状态（解锁后重新加锁）  
- 配合条件变量使用（智能锁+门铃联动）  

```cpp  
void flexible_operation() {  
    mutex mtx;  
    unique_lock<mutex> ulk(mtx, defer_lock);  // 延迟加锁（不立即关门）  
    
    if (need_lock()) {  
        ulk.lock();  // 手动加锁（决定关门）  
    }  
    
    // 临界区...  
    
    ulk.unlock();  // 临时解锁（开门取快递）  
    non_critical_work();  
    ulk.lock();    // 重新加锁（再次关门）  
    
    // 更多临界区...  
}  // 析构时自动解锁  
```  


## <span style="color:#8AAE8D">三、四种锁策略的应用场景</span>  
### <span style="color:#87CEEB">1. 占有锁（Acquiring Lock）：强制锁定资源  
**场景**：保护共享数据（如全局变量、容器）  
**类比**：银行保险柜（一次仅一人使用）  

```cpp  
std::mutex mtx;  
mtx.lock();  // 占有锁（打开保险柜）  
try {  
    shared_data.push_back(new_value);  // 操作共享资源  
} finally {  
    mtx.unlock();  // 释放锁（关闭保险柜）  
}  
```  

**与原子操作的区别**：  
- 锁可保护复杂操作序列（如读写文件+更新缓存）  
- 原子操作仅保护单一指令（如`std::atomic<int>::fetch_add`）  


### <span style="color:#87CEEB">2. 释放锁（Releasing Lock）：及时归还资源  
**场景**：避免长时间占锁（如网络请求期间释放锁）  
**类比**：图书馆预约自习室（用完立即释放）  

```cpp  
unique_lock<mutex> ulk(mtx);  
if (need_network_call()) {  
    ulk.unlock();  // 释放锁（暂时离开自习室）  
    network_request();  // 耗时操作（不阻塞他人）  
    ulk.lock();   // 重新获取锁（返回自习室）  
}  
// 析构时自动释放锁  
```  


### <span style="color:#87CEEB">3. 时间锁（Timed Lock）：设置锁超时  
**场景**：防止死锁（如分布式系统中避免永久等待）  
**类比**：自动门（等待超时后自动解锁）  

```cpp  
timed_mutex tmtx;  
if (tmtx.try_lock_for(100ms)) {  // 尝试100ms  
    // 成功获取锁（门打开）  
    tmtx.unlock();  
} else {  
    fallback_strategy();  // 超时处理（走旁门）  
}  
```  

**典型应用**：  
- 高频交易系统（毫秒级锁等待）  
- 分布式锁客户端（连接超时控制）  


### <span style="color:#87CEEB">4. 锁指针/引用：动态锁管理  
**场景**：保护动态资源（如堆分配对象）  
**类比**：移动保险箱（随资源携带锁）  

```cpp  
class DynamicResource {  
    mutex mtx;  
    Data* ptr = nullptr;  
public:  
    void update() {  
        lock_guard<mutex> lk(mtx);  // 锁指针保护  
        if (!ptr) ptr = new Data();  
        ptr->refresh();  
    }  
};  
```  

**高阶模式：Double-Checked Locking**  
```cpp  
class Singleton {  
    static atomic<Singleton*> instance;  
    static mutex mtx;  

    Singleton() {}  
public:  
    static Singleton* get() {  
        if (!instance.load()) {       // 无锁快速检查  
            lock_guard<mutex> lk(mtx); // 加锁  
            if (!instance) {           // 二次检查  
                instance = new Singleton();  
            }  
        }  
        return instance;  
    }  
};  
```  


## <span style="color:#8AAE8D">四、构造函数中的精细化锁策略</span>  
### <span style="color:#87CEEB">1. 延迟锁（Deferred Locking）：按需加锁  
**场景**：仅在必要时加锁（如对象初始化时非必须锁）  
**类比**：可选择是否上锁的抽屉  

```cpp  
class ResourceManager {  
public:  
    ResourceManager(bool need_lock)  
        : lock(mtx, defer_lock) {  // 延迟加锁（抽屉未上锁）  
        if (need_lock) {  
            lock.lock();  // 按需加锁（决定上锁）  
        }  
        // 初始化资源...  
    }  
private:  
    mutex mtx;  
    unique_lock<mutex> lock;  
};  
```  

**风险**：需确保所有路径在临界区前加锁  


### <span style="color:#87CEEB">2. 领养锁（Adopt Lock）：接管已有锁  
**场景**：封装旧代码（手动加锁后转为RAII管理）  
**类比**：继承已有的锁所有权  

```cpp  
mtx.lock();  // 手动加锁（旧方式）  
{  
    unique_lock lock(mtx, adopt_lock);  // 领养锁（转为RAII）  
    // 临界区（异常安全）  
}  // 析构时自动解锁  
```  

**跨作用域锁转移**：  
```cpp  
unique_lock<mutex> acquire_lock() {  
    mtx.lock();  
    return unique_lock(mtx, adopt_lock);  // 转移锁所有权  
}  

void use_lock() {  
    auto lock = acquire_lock();  // 直接使用已加锁的锁  
    // 临界区...  
}  // 析构自动释放  
```  


### <span style="color:#87CEEB">3. 尝试锁（Try Locking）：非阻塞加锁  
**场景**：允许加锁失败（如日志系统高并发时丢弃日志）  
**类比**：自动门尝试感应开门，失败走侧门  

**尝试锁（Try Locking）—— 构造时尝试加锁，失败则非阻塞**

- **try_to_lock** 是标记类型（tag type），而非成员函数！
**完整写法**：**std::try_to_lock**（属于std命名空间）
- **作用**：在构造 std::unique_lock/std::lock_guard 时，非阻塞尝试加锁
**（等价于先调用 mutex.try_lock()，成功则持有锁，失败则不阻塞）**
**try_to_lock**:是 std 命名空间下的标记类型，非函数必须与 unique_lock/lock_guard 的带标记构造函数配合（RAII 风格）
**替代方案**：mutex.try_lock()（手动管理锁，易漏解锁）


```cpp  
class AsyncLogger {  
public:  
    void log(const string& msg) {  
        // 尝试100ms加锁，超时则丢弃日志  
        unique_lock lock(mtx, 100ms);  
        if (lock.owns_lock()) {  
            log_file << msg << endl;  
        } else {  
            dropped_logs++;  // 降级处理  
        }  
    }  
};  
```  

**死锁预防示例**：  
```cpp  
void transfer(Account& from, Account& to, int amount) {  
    // 按地址顺序加锁，避免循环等待  
    if (&from > &to) swap(from, to);  
    
    unique_lock l1(from.mtx, defer_lock);  
    unique_lock l2(to.mtx, defer_lock);  
    
    // 尝试同时加锁，失败则重试  
    if (!try_lock(l1, l2)) {  
        retry_transfer(from, to, amount);  
    }  
    // 转账操作...  
}  
```  


## <span style="color:#8AAE8D">五、总结：锁策略对比表</span>  
| **策略**   | **构造参数**          | **加锁时机**       | **典型场景**               | **风险点**                 |  
|------------|-----------------------|--------------------|----------------------------|---------------------------|  
| 延迟锁     | `std::defer_lock`     | 手动调用`lock()`   | 条件加锁、嵌套锁优化       | 忘记加锁导致数据竞争       |  
| 领养锁     | `std::adopt_lock`     | 构造时已持有锁     | 封装旧代码、锁转移         | 非法领养未持有的锁         |  
| 尝试锁     | 时间参数（如`1s`）    | 构造时尝试加锁     | 非关键临界区、死锁预防     | 超时处理逻辑复杂           |  


## <span style="color:#8AAE8D">🌟 锁使用的黄金法则</span>  
1. **优先RAII**：使用`lock_guard`/`unique_lock`而非手动`lock/unlock`  
2. **最小作用域**：锁的作用域尽可能小（减少锁竞争）  
3. **避免嵌套**：减少嵌套加锁，必要时使用可重入锁`recursive_mutex`  
4. **超时控制**：对长时间运行的操作设置锁超时  
5. **顺序加锁**：按固定顺序获取多个锁，避免死锁  

合理使用锁机制，可让并发程序像井然有序的图书馆一样高效运行，否则可能陷入「资源争夺」的混乱局面～ 📚

**构造函数**
```cpp
unique_lock() noexcept;//(1)
unique_lock( unique_lock&& other ) noexcept; //(2)
explicit unique_lock( mutex_type& m );//(3)
unique_lock( mutex_type& m, std::defer_lock_t t ) noexcept;//(4)
unique_lock( mutex_type& m, std::try_to_lock_t t );//(5)
unique_lock( mutex_type& m, std::adopt_lock_t t );//(6)
template< class Rep, class Period >
unique_lock( mutex_type& m,
const std::chrono::duration<Rep,Period>&
timeout_duration );//(7)
template< class Clock, class Duration >
unique_lock( mutex_type& m,
const std::chrono::time_point<Clock,Duration>&
timeout_time );//(8)
```

​场景需求​	​推荐锁类型​	​C++标准实现​
简单临界区保护	基本互斥锁	std::mutex
嵌套锁/条件变量	可重入锁	std::recursive_mutex
读多写少场景	读写锁	std::shared_mutex (C++17)
超时控制要求	超时锁	std::timed_mutex
协程兼容（C++20）	无信号量（需手动封装）	std::atomic_flag+等待操作


### 进阶（单例有锁检查堆）
```cpp
std::atomic<Singleton*> instance; // 原子指针

Singleton* get_instance() {
    // 第一重检查（无锁）
    if (auto ptr = instance.load(std::memory_order_acquire); !ptr) {
        std::lock_guard lock(mtx);
        // 第二重检查
        if (!(ptr = instance.load(std::memory_order_relaxed))) {
            ptr = new Singleton();
            instance.store(ptr, std::memory_order_release); // 确保初始化完成
        }
    }
    return ptr;
}
```
概念	|RAII 实现|	底层系统调用（POSIX）|	核心价值|
|---|----|----|----
锁占有	|lock_guard/unique_lock 构造函数	|pthread_mutex_lock|	原子性保证
释放锁|	RAII 对象析构函数	|pthread_mutex_unlock	|自动防泄漏
时间锁	|try_lock_for/try_lock_until	|pthread_mutex_timedlock	|死锁规避
锁指针 / 引用	|unique_lock::mutex()	|无，仅 C++ 层封装	|条件变量等高级同步的基石|

### 尝试锁



接口	|类型|	阻塞性	|返回值	|适用场景
|----|-----|----|----|----|
mutex.try_lock()	|成员函数|	非阻塞|	bool（成功 / 失败）	|手动锁管理
std::try_to_lock|	标记类型|	非阻塞|	无（依赖锁对象状态）|	与 RAII 结合（推荐）

**核心实现：**
```cpp
// 相对时间超时（C++11）
std::unique_lock lock(mtx, std::chrono::seconds(1));

// 绝对时间超时（C++11）
auto timeout = std::chrono::system_clock::now() + std::chrono::seconds(1);
std::unique_lock lock(mtx, timeout);
unique_lock<mutex> ulk(mtx, std::try_to_lock);
```
**底层**：调用 [pthread_mutex_timedlock]，超时返回 EBUSY。

#### 适用场景：
**非关键临界区**：允许偶尔失败，降级处理
```cpp
class AsyncLogger {
public:
    void log(const std::string& msg) {
        std::unique_lock lock(mtx, std::chrono::milliseconds(100));  // 尝试 100ms
        if (lock.owns_lock()) {  // 加锁成功
            log_file << msg << "\n";
        } else {  // 降级为丢弃日志（高并发时保护主线程）
            dropped_logs++;
        }
    }
};
```
2. **死锁预防**：按顺序尝试加锁，失败则释放重试
```cpp
void transfer(Account& from, Account& to, int amount) {
    // 按地址顺序加锁，避免循环等待
    if (&from > &to) std::swap(from, to);
    
    std::unique_lock l1(from.mtx, std::defer_lock);
    std::unique_lock l2(to.mtx, std::defer_lock);
    
    // 尝试同时加锁，超时则重试
    if (std::try_lock(l1, l2) != 0) {
        retry_transfer(from, to, amount);  // 死锁发生，重试
    }
    // 临界区...
}
```
**性能优化点**：
- 避免无限阻塞，适合对延迟敏感的场景（如高频交易）。
- 配合 owns_lock() 判断，减少条件分支（比 try_lock() 更简洁）。


# 条件变量

**条件变量的引入**：condition_variable 是线程间精准同步的核心工具，是为了弥补锁只有两种状态的先天性不足，条件变量允许等待另一个变量，从而弥补互斥锁的不足，通常与互斥锁配合使用，给多线程提供一个会合的场所。
**源码**
```cpp
#include <condition_variable>
class condition_variable{
    condition_variable();
    condition_variable(const condition_variable&) = delete;
};

template< class Predicate >
void wait( std::unique_lock<std::mutex>& lock, Predicate pred);
void wait( std::unique_lock<std::mutex>& lock );
```

在**wait**中，如果**pred**返回true，**wait**则会直接返回，如果返回的是**false**，那么**wait**会堵塞到，其他线程调用**notify_one()或notify_all()为止。**

## wait的本质
### 1. wait 与轮询的本质区别（关键对比）

维度	|wait（带谓词）|	手动轮询（while (!ready)）|
|----|----|----|
CPU 占用	|阻塞时不占用 CPU（内核挂起）|	100% 占用单核（忙等待）|
锁操作	|原子释放 - 获取锁（内部实现）|	需手动管理锁（易漏解锁导致死锁）|
唤醒精度	|仅在条件变化 / 超时触发（内核通知）|	高频检查（如 1ns 轮询也可能漏掉通知）
虚假唤醒	|标准强制循环检查（内置while(predicate)）|	需手动实现循环（易遗漏）

### 解决：虚假唤醒的问题
**虚假唤醒（Spurious Wakeups）** 不是 C++ 标准库的设计缺陷，而**是操作系统线程调度的固有特性**。其底层原因包括：
**1. 信号中断**：内核可能因异步信号（如 SIGINT）意外唤醒线程
**2. 缓存一致性**：多核 CPU 下线程缓存的条件变量状态未及时同步
**3. 调度策略**：操作系统可能出于负载均衡提前唤醒等待线程（如 Linux 的 CFS 调度）

**所以为了解决虚假唤醒**
```cpp
condition_variable cv;
bool ready = false;
// 正确写法（避免虚假唤醒）unique_lock<std::mutex> lk(mtx);
cv.wait(lk, []{ return ready; });  // 内部等价于循环检查
```



### 延伸：工业级验证（Linux 内核视角）
**当线程调用std::condition_variable::wait时：**
1. 执行futex_down原子解锁（mutex.unlock()）
2. 注册到 futex 等待队列（内核维护的双向链表）
3. 线程状态切换为睡眠（TASK_INTERRUPTIBLE），CPU 资源释放
4. 通知时futex_wake唤醒队列头部线程，重新竞争锁

**证据**：通过perf trace跟踪，wait期间无用户态指令执行（与while(1)的百万级指令形成鲜明对比）。

### wait，wait_for，wait_untill的区别
接口	|阻塞机制|	超时类型|	虚假唤醒处理|	典型场景
|----|-----|-----|-----|-----
wait	|内核等待队列	|无	|必须循环|	条件同步|
wait_for	|高精度定时器	|相对时间	|自动循环|	请求超时控制
wait_until	|绝对时间戳|	绝对时间|	自动循环|	定时任务唤醒
### 实际的应用
**微服务超时**：gRPC 客户端设置 500ms 等待响应
**资源池管理**：数据库连接池等待 100ms 获取可用连接
**心跳检测**：主线程等待子线程心跳信号，超时触发重启
**反模式警告**：避免用wait_for(0)实现忙等待（应改用notify_one()+ 标志位）




## 条件变量condition_variable
### 底层
**1. 核心数据结构**
```cpp
// pthread_cond_t 底层简化实现（Linux NPTL）
typedef struct {
    int __lock;                // 互斥锁，保护等待队列
    int __wakeup;              // 唤醒标记
    struct __pthread_waitqueue __waiters; // 等待线程队列
    /* 其他平台相关字段... */
} pthread_cond_t;
```
- **等待队列**：阻塞的线程以链表形式挂起，避免忙等待。
- **互斥锁**：保护等待队列的修改（入队 / 出队），保证原子性。

**2. C++ condition_variable 的工作流程**
```cpp
condition_variable  cnv;
mutex mtx;
bool ready = false;
// 消费者线程
unique_lock<mutex> lock(mtx);
// 1. 释放锁，2. 阻塞，3. 唤醒后重新加锁
cnv.wait(lock, [](){return ready});
// 生产者线程
{
    uique_lock<mutex> lock(mtx);
    ready = true;
    cv.notify_one(); // 唤醒一个消费者
}
```
**释放锁**：wait 内部调用 lock.unlock()，允许其他线程修改条件。
**入队阻塞**：线程加入等待队列，调用 pthread_cond_wait 陷入内核态。
**原子唤醒**：生产者调用 notify_one()，内核从队列中唤醒一个线程。
**重新加锁**：被唤醒的线程调用 lock.lock()，重新占有互斥量，检查条件（防虚假唤醒）

**3. 虚假唤醒（Spurious Wakeups）的底层原因**
操作系统可能因信号中断、调度策略等非条件变更原因唤醒线程。
C++ 标准强制要求：必须用循环检查条件，而非单次 if。
```cpp
cv.wait(lock, []{ return ready; }); //本质就是循环
while (!ready) {
    cv.wait(lock); // 释放锁，阻塞
}
```
### 诞生背景
**1. 忙等待的低效性（Before condition_variable）**
```cpp
//问题：CPU 空转，资源浪费，无法处理多线程竞争。
// 错误示范：忙等待消耗 100% CPU
while (!ready) { /* 空转 */ }
```
**2. 原子性缺失的条件检查**
```cpp
// 错误示范：条件检查与等待非原子
if (ready) return; // 检查时 ready 为 false
sleep(1ms);        // 睡眠期间 ready 被置为 true，错过通知
```
**问题**：检查条件和等待之间存在时间差，导致通知丢失。

**3. condition_variable 的核心突破**
- **原子等待**：wait() 释放锁与阻塞操作原子化，避免通知丢失。
- **零 CPU 消耗**：阻塞线程挂起，仅在唤醒时消耗 CPU。
- **精准唤醒**：通过条件谓词（Predicate），避免无关线程被唤醒。


## 总结：condition_variable 的设计哲学
**原子性保障**：等待与释放锁的原子操作，避免通知丢失。
**零 CPU 消耗**：通过内核级等待队列，替代忙等待。
**精准唤醒**：结合条件谓词，最小化无效上下文切换。

### 拓展 condition_variable vs condition_variable_any
特性|	condition_variable	|condition_variable_any|
|---|-----|---
关联锁类型|	必须是 std::mutex（非递归）|	任意锁（mutex/recursive_mutex）|
操作系统依赖	|pthread_cond_t（Linux）|	pthread_condattr_setclock（更灵活）|
适用场景	|通用场景（最常用）	|需兼容不同锁类型的复杂同步|
性能	|稍优（无额外检查）|	稍差（支持任意锁）
